OUTLINE
-------

1. Shell process management
2. Working with other processes
3. Keeping things running
4. GNU screen and tmux
5. Exercises

1. Shell process management
---------------------------

So far we have only used shells in a serial fashion.  That is, we execute one
command, wait for it to complete, and then execute another.  For long-running
tasks this can become an issue.  Fortunately, shells have an assortment of
helpful features for managing processes.  First, we will talk about
backgrounding a process.  To run a process in the background, put an ``&``
after the command::

    $ cat &

The program (``cat`` in this case) is now running in the background.
The program's **stdin** is not connected to your shell at this point, so
``cat`` will not receive our keystrokes. **stdout** and **stderr**, however,
are still directed back to us, so we can see the output of the program.
You can use pipes and file redirection (as we learned about in lesson one)
with the ``&``.  While the program is running in the background, you are free
to work with the shell as you normally would.

If you have not already, run ``cat &`` as above.  You'll notice that it says
that ``cat`` is running, but it does not appear to be doing anything.  That's
because ``cat``, when given no arguments, simply cats **stdin**.  We can bring
the program into the foreground by running ``fg``::

    $ fg
    [1]  + continued  cat

Your output may appear slightly different.  Now, ``cat`` is in the foreground,
as if we had run ``cat`` without the ``&`` at all.  Anything you enter will be
echoed back to you.

We can tell ``cat`` to go away by sending it the interrupt signal (**SIGINT**)
via our shell.  To do this, type ctrl-c (``^C``).

**An aside**: in Unix, the ctrl key is signified by the carat (``^``) and means
"hit ctrl and the next letter at the same time"; we'll use this convention
from now on.

**Another aside**: signals generated by key combinations like ``^C`` are only
sent to processes running in the foreground.

Most processes respond to **SIGINT** by cleaning up whatever they are doing
and then exiting.  Note that this is only by convention; programmers are free
to treat **SIGINT** however they like, including just ignoring it entirely.

Suppose that you have started a program, but forgot to include the ``&``.  Not
a problem: you can suspend the execution of a program using ``^Z``.  Try it
with ``cat`` again::

    $ cat
    ^Z
    zsh: suspended  cat

Again, your output may differ.  The important thing is that ``cat`` has been
suspended.  This means that it is **not running at all**.  It is, in effect,
"frozen".  You can start the program running again by either running ``fg``
(to bring it into the foreground) or ``bg`` (to put it in the background).
We can demonstrate that the program really is frozen by the following::

    $ sh -c 'for i in `seq 1 9999`; do echo $i; sleep 2; done'

Every two seconds, the next integer will be printed (starting with 1).  If you
suspend the process, wait any length of time, and then bring it back into the
foreground, it will continue where it left off.

One more thing: you aren't limited to just one suspended or backgrounded
process.  First, get back to your shell prompt.  You can list all running jobs
in your shell by running ``jobs``.  Let's try it::

    $ cat
    zsh: suspended  cat
    ^Z
    $ top
    ^Z
    zsh: suspended (signal)  top
    $ jobs
    jobs
    [1]  + suspended  cat
    [2]  - suspended (signal)  top

Again, your output may be different depending on your shell and the processes
you are running.  When using ``bg`` or ``fg``, you can refer to a specific job
by its number.  Make sure to prefix the job number with a ``%``::

    $ fg %1
    [1]  - continued  cat

Further reading: your shell's manual.  ``bash(1)`` has a good explanation of
shell jobs in the **JOB CONTROL** section.

2. Working with other processes
-------------------------------

Most of the processes on your system are probably not your shell's background
jobs.  You can still communicate with these processes through signals.  First,
you need to find the target process' process ID (PID).  The ``ps`` program can
tell you the PIDs of processes::

    $ ps -e

Note the ``-e`` option, which tells ``ps`` to list all processes running on
our system, not just the ones we have run from the current shell.

**Note**: ``ps`` is odd in the way it takes options.  Specifically, there are
"BSD" options and "POSIX/Unix" options.  See ``ps(1)`` for more information.

For now, let's get the PID of the shell we are using currently::

    $ ps
      PID TTY          TIME CMD
     3165 pts/5    00:00:00 zsh
    16557 pts/5    00:00:00 ps

My shell is ``zsh`` and its PID is 3165.  We can send a signal to the shell
using the ``kill`` command.  Per the manual, ``kill(1)``, the default signal
is **SIGTERM**, which (by convention) tells the process to terminate
gracefully.  Try it now, making sure to replace 3165 by the PID of your shell::

    $ kill 3165

If your shell is anything like mine, nothing happened.  It must have ignored
**SIGTERM**, or if it did anything we sure can't see it.  If you really want a
process to die and it will not respond to **SIGTERM**, the next step is
**SIGKILL**, which you should use sparingly.  It immediately terminates the
target process (unless it is a "zombie"; see
http://en.wikipedia.org/wiki/Zombie_process for more information).
**SIGKILL** cannot be ignored or specially handled by the program.  Let's use
**SIGKILL** on our stubborn shell::

    $ kill -9 3165

Note that 9 is the signal number for **SIGKILL**.  You can also use
``-SIGKILL`` instead of ``-9``.  What happens after you forcefully terminate
your shell depends on your terminal emulator, but most likely it will simply
disappear.  Konsole (in my case) spits out an error message.

Remember, only use **SIGKILL** on stubborn programs that will not close
through other means. **SIGTERM** is preferred as it allows the process to
clean up open files, etc.  **SIGKILL** can cause data loss if a program has
data waiting to be written to disk.

3. Keeping things running
-------------------------

You may have noticed already that (at least for many programs) if you run
something in a shell and then close the terminal emulator, that program just
quits.  You can see this for yourself with ``xmessage``::

    $ xmessage 'test'

Now close the terminal emulator you ran the command in.  The ``xmessage`` box
will disappear.  Why did this happen?

The parent process of ``xmessage`` (your shell) finished, so ``xmessage`` was
sent the hang up signal (**SIGHUP**, see
http://www.kingcomputerservices.com/unix_101/sending_signals.htm for more
information) which caused it to quit.  You can make the process immune to
**SIGHUP** by prepending ``nohup``::

    $ nohup xmessage 'test'

Now closing the terminal will not cause ``xmessage`` to exit.

You can also use a shell builtin command, ``disown``, to keep jobs from being
sent **SIGHUP**.  See your shell manual for more information.  ``bash(1)`` has
a decent explanation under the **SIGNALS** header.

4. GNU screen and tmux
----------------------

``screen(1)`` and ``tmux(1)`` are *terminal multiplexers*.  From within a
``screen`` or ``tmux`` session, you can launch additional terminals, split the
window into two or more terminals, copy and paste between them (without using
your terminal emulators copy/paste functionality), and more.  Most
importantly, you can start a ``screen`` or ``tmux`` session, disconnect from
it (leaving the shells and programs inside running) and then reconnect to it
later to pick up where you left off.

I (kdorf) have used both ``screen`` and ``tmux``.  They both have similar
functionality, but I would recommend using ``tmux`` since it is much easier to
configure and still under active development.

5. Exercises
------------

This has been a short lesson compared to most, but the exercise will make up
for that.

1. Install and become familiar with ``screen`` or ``tmux``.  You should know
how to create new windows, run multiple "panes" in one window, switch between
panes and windows, scroll up to view old output, copy/paste using
``screen``/``tmux`` facilities, disconnect from a session, reconnect to a
session, and run multiple sessions at once on the same machine.

Google has some good resources for learning these programs.  Search for "gnu
screen tutorial" or "tmux tutorial".  The first few results should get you
started.  You can also, as always, refer to the manual pages: ``screen(1)`` or
``tmux(1)``.  Lastly, don't forget that we are here to answer questions!

.. vim:set et tw=78:
